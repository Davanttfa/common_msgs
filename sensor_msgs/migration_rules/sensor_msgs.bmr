class update_robot_msgs_PointCloud_c47b5cedd2b77d241b27547ed7624840(MessageUpdateRule):
	old_type = "robot_msgs/PointCloud"
	old_full_text = """
Header header
Point32[] pts
ChannelFloat32[] chan

================================================================================
MSG: roslib/Header
#Standard metadata for higher-level flow data types
#sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.secs: seconds (stamp_secs) since epoch
# * stamp.nsecs: nanoseconds since stamp_secs
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

================================================================================
MSG: robot_msgs/Point32
float32 x
float32 y
float32 z
================================================================================
MSG: robot_msgs/ChannelFloat32
string name
float32[] vals
"""

	new_type = "sensor_msgs/PointCloud"
	new_full_text = """
Header header
geometry_msgs/Point32[] points
ChannelFloat32[] channels

================================================================================
MSG: roslib/Header
#Standard metadata for higher-level flow data types
#sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.secs: seconds (stamp_secs) since epoch
# * stamp.nsecs: nanoseconds since stamp_secs
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

================================================================================
MSG: geometry_msgs/Point32
float32 x
float32 y
float32 z
================================================================================
MSG: sensor_msgs/ChannelFloat32
string name
float32[] values
"""

	order = 0
	migrated_types = [
		("Header","Header"),
                ("Point32","geometry_msgs/Point32"),
                ("ChannelFloat32","ChannelFloat32")]

	valid = True

	def update(self, old_msg, new_msg):
		self.migrate(old_msg.header, new_msg.header)
		self.migrate_array(old_msg.pts, new_msg.points, "geometry_msgs/Point32")
		self.migrate_array(old_msg.chan, new_msg.channels, "ChannelFloat32")


class update_robot_msgs_ChannelFloat32_61c47e4621e471c885edb248b5dcafd5(MessageUpdateRule):
	old_type = "robot_msgs/ChannelFloat32"
	old_full_text = """
string name
float32[] vals
"""

	new_type = "sensor_msgs/ChannelFloat32"
	new_full_text = """
string name
float32[] values
"""

	order = 0
	migrated_types = []

	valid = True

	def update(self, old_msg, new_msg):
		new_msg.name = old_msg.name
		new_msg.values = old_msg.vals

class update_image_msgs_Image_97d4ca3868dc81af4a2403bcb6558cb0(MessageUpdateRule):
	old_type = "image_msgs/Image"
	old_full_text = """
Header header        # Header
string label         # Label for the image
string encoding      # Specifies the color encoding of the data
                     #   Acceptable values are:
                     #    1 channel types:
                     #     mono, bayer_rggb, bayer_gbrg, bayer_grbg, bayer_bggr
                     #    3 channel types:
                     #     rgb, bgr
                     #    4 channel types:
                     #     rgba, bgra, yuv422
                     #    6 channel types:
                     #     yuv411
                     #    N channel types:
                     #     other
string depth         # Specifies the depth of the data:
                     #   Acceptable values:
                     #    uint8, int8, uint16, int16, uint32, int32, uint64, int64, float32, float64

# Based on depth ONE of the following MultiArrays may contain data.
# The multi-array MUST have 3 dimensions, labeled as "height",
# "width", and "channel", though depending on usage the ordering of
# the dimensions may very.  Note that IPL Image convention will order
# these as: height, width, channel, which is the preferred ordering
# unless performance dictates otherwise.
#
# Height, width, and number of channels are specified in the dimension
# sizes within the appropriate MultiArray

std_msgs/UInt8MultiArray   uint8_data
std_msgs/Int8MultiArray    int8_data
std_msgs/UInt16MultiArray  uint16_data   
std_msgs/Int16MultiArray   int16_data
std_msgs/UInt32MultiArray  uint32_data
std_msgs/Int32MultiArray   int32_data
std_msgs/UInt64MultiArray  uint64_data
std_msgs/Int64MultiArray   int64_data
std_msgs/Float32MultiArray float32_data
std_msgs/Float64MultiArray float64_data

================================================================================
MSG: roslib/Header
#Standard metadata for higher-level flow data types
#sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.secs: seconds (stamp_secs) since epoch
# * stamp.nsecs: nanoseconds since stamp_secs
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

================================================================================
MSG: std_msgs/UInt8MultiArray
# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
uint8[]           data          # array of data


================================================================================
MSG: std_msgs/MultiArrayLayout
# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding bytes at front of data

# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
# 
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/Int8MultiArray
# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
int8[]            data          # array of data


================================================================================
MSG: std_msgs/UInt16MultiArray
# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
uint16[]            data        # array of data


================================================================================
MSG: std_msgs/Int16MultiArray
# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
int16[]           data          # array of data


================================================================================
MSG: std_msgs/UInt32MultiArray
# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
uint32[]          data          # array of data


================================================================================
MSG: std_msgs/Int32MultiArray
# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
int32[]           data          # array of data


================================================================================
MSG: std_msgs/UInt64MultiArray
# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
uint64[]          data          # array of data


================================================================================
MSG: std_msgs/Int64MultiArray
# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
int64[]           data          # array of data


================================================================================
MSG: std_msgs/Float32MultiArray
# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
float32[]         data          # array of data


================================================================================
MSG: std_msgs/Float64MultiArray
# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
float64[]         data          # array of data
"""

	new_type = "sensor_msgs/Image"
	new_full_text = """
Header header        # Header

# The legal values for encoding are in file src/image_encodings.cpp
# If you want to standardize a new string format, join ros-users@lists.sourceforge.net and send an email proposing a new encoding.

string encoding       # Encoding of pixels -- channel meaning, ordering, size -- taken from the list of strings in src/image_encodings.cpp
uint32 step           # Full row length in bytes
uint8[] data          # actual matrix data, size is (step * rows)
uint32 height         # image height, that is, number of rows
uint32 width          # image width, that is, number of columns
uint8 is_bigendian    # is this data bigendian

================================================================================
MSG: roslib/Header
#Standard metadata for higher-level flow data types
#sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.secs: seconds (stamp_secs) since epoch
# * stamp.nsecs: nanoseconds since stamp_secs
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id
"""

	order = 0
	migrated_types = [
		("Header","Header"),]

	valid = True

	def update_mono_uint8(self, old_msg, new_msg):
                assert (len(old_msg.uint8_data.layout.dim) == 3 and
                        old_msg.uint8_data.layout.dim[0].label == 'height' and
                        old_msg.uint8_data.layout.dim[1].label == 'width' and
                        old_msg.uint8_data.layout.dim[2].label == 'channel'), \
                        'This rule only supports migration images with 3 dimensions ordered: height, width, channel'

		self.migrate(old_msg.header, new_msg.header)
		new_msg.encoding = 'mono8'
		new_msg.step = old_msg.uint8_data.layout.dim[1].stride
		new_msg.data = old_msg.uint8_data.data
		new_msg.height = old_msg.uint8_data.layout.dim[0].size
		new_msg.width = old_msg.uint8_data.layout.dim[1].size
		new_msg.is_bigendian = 0

	def update_rgb_uint8(self, old_msg, new_msg):
                assert (len(old_msg.uint8_data.layout.dim) == 3 and
                        old_msg.uint8_data.layout.dim[0].label == 'height' and
                        old_msg.uint8_data.layout.dim[1].label == 'width' and
                        old_msg.uint8_data.layout.dim[2].label == 'channel'), \
                        'This rule only supports migration images with 3 dimensions ordered: height, width, channel'

		self.migrate(old_msg.header, new_msg.header)
		new_msg.encoding = 'rgb8'
		new_msg.step = old_msg.uint8_data.layout.dim[1].stride
		new_msg.data = old_msg.uint8_data.data
		new_msg.height = old_msg.uint8_data.layout.dim[0].size
		new_msg.width = old_msg.uint8_data.layout.dim[1].size
		new_msg.is_bigendian = 0

	def update_bgr_uint8(self, old_msg, new_msg):
                assert (len(old_msg.uint8_data.layout.dim) == 3 and
                        old_msg.uint8_data.layout.dim[0].label == 'height' and
                        old_msg.uint8_data.layout.dim[1].label == 'width' and
                        old_msg.uint8_data.layout.dim[2].label == 'channel'), \
                        'This rule only supports migration images with 3 dimensions ordered: height, width, channel'

		self.migrate(old_msg.header, new_msg.header)
		new_msg.encoding = 'bgr8'
		new_msg.step = old_msg.uint8_data.layout.dim[1].stride
		new_msg.data = old_msg.uint8_data.data
		new_msg.height = old_msg.uint8_data.layout.dim[0].size
		new_msg.width = old_msg.uint8_data.layout.dim[1].size
		new_msg.is_bigendian = 0

        def update(self, old_msg, new_msg):
                encoding_map = {('mono', 'uint8'): self.update_mono_uint8,
                                ('rgb', 'uint8'): self.update_rgb_uint8,
                                ('bgr', 'uint8'): self.update_bgr_uint8}
                key = (old_msg.encoding, old_msg.depth)
        
                assert key in encoding_map, 'This rule does not support migrating from %s %s'%key

                encoding_map[key](old_msg, new_msg)

